---
title: "Speed-Accuracy"
author: "Kyle MacDonald"
date: "October 1, 2015"
output: html_document
---

# Data processing, plotting, and analysis script 

There are 4 different types of center fixations in this dataset:

1. ASL (27 kids: 18-54m, median age = 27 months): human signing
2. Face (22 kids: 26m): human face talking
3. Trio (18 kids at 26m and 22 kids at 36m): static images of real world objects, e.g., cats
4. Bull (22 kids at 26m): different static "bullseyes"

```{r chunk_options, echo = F}
rm(list=ls()) # code to clear workspace

knitr::opts_chunk$set(warning=F, message=F, sanitize = T, 
                      fig.height=5, fig.width=8, echo=T, cache = T)

set.seed(0) # to reproduce simulations

# devtools::install_github("langcog/langcog")
library(langcog)
library(magrittr)
library(RWiener)
library(stringr)
library(GGally)
library(kmr)
library(lme4)
library(lsr)
library(plyr)
library(gridExtra)
library(dplyr)
library(tidyr)
library(ggplot2)
theme_set(theme_bw()) # set the ggplot theme that we think is pretty
setwd("/home/gryfalconess/Documents/CSLI/speed-acc")
```


## Read Data

Eye movement data

```{r}
df <- read.csv("data/3_final_merged_data/speed-acc-ss-df.csv", 
               check.names=F, stringsAsFactors=F) 

df %<>% mutate(stimuli = ifelse(stimuli == "V1" | stimuli == "V2", "ASL", 
                          ifelse(stimuli == "Trio", "Object", 
                                 ifelse(stimuli == "Bull", "Bullseye",
                                        stimuli))),
         stimuli = factor(stimuli, levels = c("ASL", "Face", "Object", "Bullseye")))
```

## Descriptives

How many participants in each stimuli set and language modality? `Age_code_m` is a hacky way
to track the different age groups that saw the Trio stimuli.

```{r}
df %>% 
  select(Sub.Num, language_modality, age_code, stimuli) %>% 
  unique() %>% 
  group_by(language_modality, age_code, stimuli) %>% 
  summarise(count = n()) %>% 
  knitr::kable()
```

What are the age distributions across language modalities?

```{r}
df %>% 
  filter(age_code == "child") %>% 
  select(Sub.Num, language_modality, age_code, stimuli, age_years) %>% 
  unique() %>%
  ggplot(aes(age_years, fill = language_modality)) +
  geom_histogram() +
  scale_fill_solarized() +
  facet_grid(.~language_modality) +
  guides(fill = F)
```

ASL group has wide range of ages; whereas the spoken language kids are tightly clustered around 2 and 3 years of age.

## Accuracy analysis

First we need to get proportion correct for each participant in each age group and language modality.

```{r}
ss_prop <- df %>% 
  group_by(Sub.Num, age_code, Months, language_modality, 
           stimuli, hearing_status_participant) %>% 
  filter(trial_type != "no_shift") %>% 
  summarise(mean_correct = mean(correct))

ss_prop <- df %>% 
  group_by(Sub.Num, age_code, Months, language_modality, stimuli, correct, 
           hearing_status_participant) %>%
  filter(trial_type != "no_shift") %>% 
  summarise(mean_rt = mean(RT)) %>% 
  left_join(ss_prop)
```

Plot.

```{r}
ms <- ss_prop %>%
  filter(age_code == "child", correct == 1) %>%
  group_by(language_modality, age_code, stimuli) %>% 
  multi_boot_standard(column = "mean_correct") 

ggplot(aes(x = stimuli, y = mean, fill = language_modality), data = ms) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper),  
                 position = position_dodge(width = 0.9)) +
  geom_hline(yintercept = 0.5, lty = "dashed") +
  xlab(NULL) +
  ylab("Mean Accuracy") +
  scale_fill_solarized() +
  theme(text = element_text(size=36)) +
  guides(fill = F) +
  ggtitle("Accuracy")
```

When we plot the average proprotion of correct shifting, we see that the ASL group was the most accurate, followed by Face, and then Trio and Bull.

We can model proportion correct as a function of stimuli set.

```{r}
m1_lm <- lm(mean_correct ~ stimuli, 
            data = filter(ss_prop, age_code == "child", correct == 1))

knitr::kable(summary(m1_lm)$coef, digits = 3)
```

All groups were worse than the ASL kids. 

TODO: Model with effect coding to test specific contrasts.

### RT analysis

Get medians and CIs for correct/inccorect shifts for each stimuli set and language modality 

```{r}
ms_rt <- ss_prop %>%
  filter(age_code == "child") %>% 
  group_by(language_modality, age_code, stimuli, correct) %>% 
  multi_boot_standard(column = "mean_rt", na.rm = T, empirical_function = "median")
```

Plot the summary measures.

```{r}
ms_rt$stimuli <- factor(ms_rt$stimuli, levels = c("Bullseye", "Object", "Face", "ASL"))

ggplot(aes(x = stimuli, y = median, fill = language_modality), 
       data = filter(ms_rt, correct == 1)) + 
  geom_bar(stat = "identity", position = position_dodge()) + 
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper), 
                 position = position_dodge(width = 0.9)) +
  scale_fill_solarized() +
  guides(fill = F) + 
  theme(text = element_text(size=36)) +
  xlab(NULL) +
  ylab("Median RT") +
  coord_flip() +
  ggtitle("Reaction Time")
```

Plot RTs for coorect/incorrect tirals

```{r}
ggplot(aes(x = as.factor(correct), y = median, fill = as.factor(correct)), 
       data = ms_rt) + 
  geom_bar(stat = "identity", position = position_dodge()) + 
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper), 
                 position = position_dodge(width = 0.9)) +
  facet_grid(stimuli~age_code) +
  scale_fill_solarized() +
  guides(fill = F) + 
  theme(text = element_text(size=18)) +
  xlab("Response Type") +
  ylab("Mean RT") +
  coord_flip()
```

We see some evidence of speed accuracy tradeoffs in the ASL, Face, and Bull conditions, but not in the Trio condition. Why do medians look so much better than means? 

### Plot distributions of correct and incorrect RTs

Note the RT cutoff for the long tail. When you cutoff more of the tail, the difference between median correct and inccorrect shifting increases. It's interesting to think about whether RTs in these long tails are meaningful. 

```{r}
med_all <- df %>% 
  group_by(age_code, language_modality, stimuli, correct) %>% 
  mutate(log_RT = log(RT)) %>% 
  multi_boot_standard(column = "RT", na.rm = T, empirical_function = "median")

med_all %<>% mutate(Response.Type = ifelse(correct == 1, "Correct", "Incorrect")) %>% 
  mutate(Response.Type = factor(Response.Type, levels = c("Incorrect", "Correct")))

df %<>% mutate(Response.Type = ifelse(correct == 1, "Correct", "Incorrect")) %>% 
  mutate(Response.Type = factor(Response.Type, levels = c("Incorrect", "Correct")))

ggplot(aes(x = RT, fill = Response.Type), 
       data = filter(df, age_code == "child")) +
  geom_density(alpha = 0.7, adjust = 1.5) + 
  facet_grid(.~stimuli) +
  geom_vline(aes(xintercept = median, color = Response.Type), size = 1, lty = "dashed", 
             data = filter(med_all, age_code == "child")) +
  guides(color = F) + 
  ylab("Density") +
  scale_fill_manual(values = c("orangered", "green3")) +
  scale_color_manual(values = c("orangered", "green4")) +
  theme(text = element_text(size=24),
        legend.position = "top",
        panel.margin = unit(2, "lines")) +
  scale_y_continuous(breaks = c(0, .001)) +
  scale_x_continuous(breaks = c(0, 1000, 2000))
```

Again we see evidence of a speed-acc tradeoff for ASL, Face, and maybe Bull. But the Trio distributions are right on top of each other. 

### Plot Bunny RTs as a function of age

There were data from both 26 and 36 month olds on the Trio stimuli set. Here we disaggregate and plot the RT dists separately.

```{r}
med_trio <- df %>% 
  filter(stimuli == "Object") %>% 
  group_by(experiment, language_modality, stimuli, correct) %>% 
  multi_boot_standard(column = "RT", na.rm = T, empirical_function = "mean")

ggplot(aes(x = RT, fill = as.factor(correct)), 
       data = filter(df, age_code == "child", stimuli == "Object")) +
  geom_density(alpha = 0.5) + 
  facet_wrap(~experiment) +
  labs(fill = "Correct") +
  guides(color = F) +
  scale_fill_solarized() +
  scale_color_solarized()
```

Kids aren't getting better at this between 2 and 3? 

### Plot Adult data

We can compare the adult data for ASL and Bull. 

```{r}
library("gridExtra")

ms_adults <- ss_prop %>%
  filter(age_code == "adult") %>% 
  group_by(language_modality, stimuli) %>% 
  multi_boot_standard(column = "mean_correct") 

b <- ggplot(aes(x = stimuli, y = mean), data = ms_adults) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper),  
                 position = position_dodge(width = 0.9)) +
  geom_hline(yintercept = 0.5, lty = "dashed") +
  xlab(NULL) +
  ylab("Mean Accuracy") +
  scale_fill_solarized() +
  theme(text = element_text(size=20)) +
  guides(fill = F) +
  ggtitle("Accuracy")

## RT
ms_adults_rt <- ss_prop %>%
  filter(age_code == "adult") %>% 
  group_by(language_modality, stimuli) %>% 
  multi_boot_standard(column = "mean_rt", empirical_function = "median") %>% 
  mutate(stimuli = factor(stimuli, levels = c("Bullseye", "ASL")))

a <- ggplot(aes(x = stimuli, y = median), data = ms_adults_rt) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper),  
                 position = position_dodge(width = 0.9)) +
  xlab(NULL) +
  ylab("Mean Accuracy") +
  scale_fill_solarized() +
  theme(text = element_text(size=20)) +
  scale_y_continuous(breaks = c(0, 250, 500, 750)) +
  xlab(NULL) +
  ylab("Median RT") +
  coord_flip() +
  ggtitle("Reaction Time") +
  guides(fill = F)

gridExtra::grid.arrange(a, b, ncol = 2)
```

Plot distributions of correct and incorrect RTs

```{r}
med_adults <- df %>% 
  filter(age_code == "adult") %>% 
  group_by(experiment, language_modality, stimuli, correct) %>% 
  multi_boot_standard(column = "RT", na.rm = T, empirical_function = "mean")

ggplot(aes(x = RT, fill = as.factor(correct)), 
       data = filter(df, age_code == "adult")) +
  geom_histogram(alpha = 0.5) + 
  facet_grid(experiment~.) +
  geom_vline(aes(xintercept = mean, color = as.factor(correct)), size = 1, 
             data = med_adults) +
  labs(fill = "Correct") +
  guides(color = F) +
  scale_fill_solarized() +
  scale_color_solarized()
```

Adult data makes sense. For Bull, we see that incorrect shifts tend to occur sooner. We can also see that there are not very many incorrect shifts for the ASL participants, so hard to see any evidence of speed-accuracy tradeoffs when > 90% accurate.

### Model association between acc and rt

Best way to model this? 

```{r}
library("lme4")
m1 <- lme4::glmer(correct ~ log2(RT) * stimuli + (1|Sub.Num), 
                  data = filter(df, age_code == "child"),
                  family = "binomial",
                  nAGQ=0)

knitr::kable(summary(m1)$coef, digits = 3)
```

RT does predict Accuracy. Longer RTs mean you are more likely to be correct. Depending on the long tail cutoff that you use of the RT distributions, you see different interactions. At cutoff of 3000ms, the interaction between RT and Trio is marginal. At an earlier cutoff of 2500ms, the interaction is robust. At a cutoff of 2000ms, the two-way interactions between RT and both Trio and Bull stimuli are significant. 

# Coda vs. Deaf

Plot distributions of correct and incorrect RTs

```{r}
ms_coda_acc <- ss_prop %>%
  filter(age_code == "child", stimuli == "ASL") %>% 
  group_by(hearing_status_participant, stimuli) %>% 
  multi_boot_standard(column = "mean_correct") %>% 
  ungroup() %>% 
  mutate(hearing_status_participant = factor(hearing_status_participant, 
                                             levels=c("hearing", "deaf")))

b <- ggplot(aes(x = hearing_status_participant, y = mean), 
       data = ms_coda_acc) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper),  
                 position = position_dodge(width = 0.9)) +
  geom_hline(yintercept = 0.5, lty = "dashed") +
  xlab(NULL) +
  ylab("Mean Accuracy") +
  theme(text = element_text(size=20)) +
  guides(fill = F) +
  ggtitle("Accuracy") +
  scale_fill_solarized() 

ms_coda_rt <- ss_prop %>% 
  filter(age_code == "child", stimuli == "ASL") %>% 
  group_by(stimuli, hearing_status_participant) %>% 
  multi_boot_standard(column = "mean_rt", na.rm = T, empirical_function = "median") %>% 
  mutate(hearing_status_participant = factor(hearing_status_participant, 
                                             levels=c("hearing", "deaf")))

a <- ggplot(aes(x = hearing_status_participant, y = median), 
            data = ms_coda_rt) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper),  
                 position = position_dodge(width = 0.9)) +
  xlab(NULL) +
  ylab("Mean Accuracy") +
  scale_fill_solarized() +
  theme(text = element_text(size=20)) +
  xlab(NULL) +
  ylab("Median RT") +
  coord_flip() +
  ggtitle("Reaction Time") +
  guides(fill = F) +
  scale_y_continuous(breaks = c(0, 500, 1000))

gridExtra::grid.arrange(a, b, ncol = 2)
```

# Drift Diffusion Analysis

Workflow taken from Nordmeyer et al. (2016). The goal is to estimate parameters separately for each participant and then we aggregate across participants to get means & confidence intervals on the parameters.

The parameters of the drift drift diffusion model are: 

* $\alpha$ = boundary separation: speed-accuracy tradeoff (higher values mean higher accuracy)
* $\beta$ = initial bias
* $\delta$ = drift rate: speed of information processing (close to zero means ambiguous information)
* $\tau$ = nondecision time: motor response time

## Estimating parameters

```{r setuppars}
# get the data we care about and format for Rwiener functions
# columns need to be named "q" for RT and "resp" for response
d <- df %>% 
  filter(age_code == "child", trial_type != "no_shift", is.na(RT_sec) == F, RT_sec > .1) %>% 
  select(Sub.Num, stimuli, RT_sec, correct, hearing_status_participant, Months) %>% 
  mutate(resp = factor(correct),
         resp = plyr::revalue(resp, c("0" = "lower", "1" = "upper")),
         resp = relevel(resp, "upper")) %>% 
  rename(q = RT_sec)
```

```{r}
sub.pars <- data.frame(Separation = numeric(),
                       Non.Decision = numeric(),
                       Bias = numeric(),
                       Drift = numeric(),
                       Condition = character(),
                       Hearing.Status = character(),
                       Age.Months = character(),
                       Sub.Num = character(),
                       stringsAsFactors = F)


#because RWiener is finicky:
d$resp <- as.character(d$resp)
```

```{r estpars}
conditions <- unique(as.character(d$stimuli))
subs <- unique(as.character(d$Sub.Num))

for (j in 1:length(subs)) {
  sid <- as.character(subs[j]) 
  dat <- as.data.frame(filter(d, Sub.Num == sid))
  condition_type <- unique(as.character(dat$stimuli))
  hearing_status <- unique(as.character(dat$hearing_status_participant))
  age <- unique(as.character(dat$Months))
  # fit ddm for each participant 
  opt <- optim(c(1, .1, .1, 1), wiener_deviance, 
               dat=select(dat, c(q, resp)), method="Nelder-Mead")
  pars <- c(opt$par, condition_type, hearing_status, age, sid)
  sub.pars[j,] <- pars
} 
```

### Plot Parameters

This plot shows the mean parameter values & 95% C.I.s for each stimuli type

```{r plotpars, fig.width=8, fig.height=6}
sub.pars$Separation <- as.numeric(sub.pars$Separation)
sub.pars$Non.Decision <- as.numeric(sub.pars$Non.Decision)
sub.pars$Bias <- as.numeric(sub.pars$Bias)
sub.pars$Drift <- as.numeric(sub.pars$Drift)
sub.pars$Age.Months <- as.numeric(sub.pars$Age.Months)

sub.pars <- sub.pars %>% 
  group_by(Condition) %>%
  filter(Separation < mean(Separation) + 3 * sd(Separation), 
         Separation > mean(Separation) - 3 * sd(Separation)) %>%
  filter(Non.Decision < mean(Non.Decision) + 3 * sd(Non.Decision), 
         Non.Decision > mean(Non.Decision) - 3 * sd(Non.Decision)) %>%
  filter(Bias < mean(Bias) + 3 * sd(Bias), 
         Bias > mean(Bias) - 3 * sd(Bias)) %>%
  filter(Drift < mean(Drift) + 3 * sd(Drift), 
         Drift > mean(Drift) - 3 * sd(Drift)) %>%
  ungroup() %>%
  na.omit()

sub.pars %<>% gather(Param, Value, Separation:Drift)
```

Plot distributions of parameters across conditions

```{r}
ggplot(aes(x = Value, fill = Condition), 
       data = filter(sub.pars, Param %in% c("Drift", "Separation"))) +
  geom_density(alpha = 0.7, adjust = 1.5) + 
  facet_grid(.~Param, scales = "free") +
  scale_fill_solarized()
```

Get means and CIs for parameter values and plot

```{r}
sub.pars.ms <- sub.pars %>%
  group_by(Condition, Param) %>%
  multi_boot_standard(column = "Value", empirical_function = "mean")

sub.pars.ms$Condition <- factor(sub.pars.ms$Condition, 
                                levels = c("ASL", "Face", "Object", "Bullseye"))

sub.pars.ms$language_modality <- ifelse(sub.pars.ms$Condition == "ASL", "ASL", "English")

ggplot(aes(x = Condition, y = mean, fill = language_modality), 
       data = filter(sub.pars.ms, Param %in% c("Drift", "Separation"))) +
  geom_bar(stat = "identity") + 
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper)) +
  facet_wrap(~Param, ncol = 4) +
  scale_fill_solarized() + 
  ylab("Mean Param Value") +
  guides(fill = F) +
  theme(text = element_text(size = 30)) 
```

## model parameter values

What is the association between age/condition and parameter values of interest (drift and boundary separation)?

```{r}
ddm1.a <- lm(Value ~ Condition + Age.Months, 
           data = filter(sub.pars, Param %in% c("Drift")))

ddm2.a <- lm(Value ~ Condition + Age.Months, 
             data = filter(sub.pars, Param %in% c("Separation")))

# models not controlling for age
ddm1.b <- lm(Value ~ Condition, data = filter(sub.pars, Param %in% c("Drift")))
ddm2.b <- lm(Value ~ Condition, data = filter(sub.pars, Param %in% c("Separation")))
```

What is the association between age and parameter values?

```{r}
ddm.age.drift <- lm(Value ~ Age.Months, data = filter(sub.pars, Param %in% c("Drift")))
ddm.age.sep <- lm(Value ~ Age.Months, data = filter(sub.pars, Param %in% c("Separation")))

## fit models just within ASL sample
ddm.age_asl_drift <- lm(Value ~ Age.Months, data = filter(sub.pars, Condition == "ASL", 
                                                 Param %in% c("Drift")))

ddm.age_asl_sep <- lm(Value ~ Age.Months, data = filter(sub.pars, Condition == "ASL", 
                                                 Param %in% c("Separation")))
```

### Compare DDM fits for Deaf and Hearing signers

```{r}
sub.pars.ms.coda <- sub.pars %>% 
  filter(Condition == "ASL") %>% 
  group_by(Hearing.Status, Param) %>% 
  multi_boot_standard(column = "Value", empirical_function = "mean")

ggplot(aes(x = Param, y = mean, fill = Hearing.Status), 
       data = filter(sub.pars.ms.coda, Param %in% c("Drift", "Separation"))) +
  geom_bar(stat = "identity", position = position_dodge()) + 
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper), 
                 position = position_dodge(width=0.9)) +
  theme(text = element_text(size = 30)) +
  xlab("Parameter") +
  ylab("Mean Param Value")
```

### Fit DDM to adult data for ASL and Bull

```{r setuppars adults}
# get the data we care about and format for Rwiener functions
# columns need to be named "q" for RT and "resp" for response
d.adults <- df %>% 
  filter(age_code == "adult", trial_type != "no_shift", is.na(RT_sec) == F, RT_sec > .1) %>% 
  select(Sub.Num, stimuli, RT_sec, correct) %>% 
  mutate(resp = factor(correct),
         resp = plyr::revalue(resp, c("0" = "lower", "1" = "upper")),
         resp = relevel(resp, "upper")) %>% 
  rename(q = RT_sec)

sub.pars <- data.frame(Separation = numeric(),
                       Non.Decision = numeric(),
                       Bias = numeric(),
                       Drift = numeric(),
                       Condition = character(),
                       Sub.Num = character(),
                       stringsAsFactors = F)


#because RWiener is finicky:
d.adults$resp <- as.character(d.adults$resp)
```

```{r estpars adults}
conditions <- unique(as.character(d.adults$stimuli))
subs <- unique(as.character(d.adults$Sub.Num))

for (j in 1:length(subs)) {
  sid <- as.character(subs[j]) 
  dat <- as.data.frame(filter(d.adults, Sub.Num == sid))
  condition_type <- unique(as.character(dat$stimuli))
  # fit ddm for each participant 
  opt <- optim(c(1, .1, .1, 1), wiener_deviance, 
               dat=select(dat, c(q, resp)), method="Nelder-Mead")
  pars <- c(opt$par, condition_type, hearing_status, sid)
  sub.pars[j,] <- pars
} 
## "Warning: In matrix(value, n, p) : data length [7] is not a sub-multiple or multiple of the number of columns [6]"
```

Munge param values.

```{r plot params adults}
sub.pars$Separation <- as.numeric(sub.pars$Separation)
sub.pars$Non.Decision <- as.numeric(sub.pars$Non.Decision)
sub.pars$Bias <- as.numeric(sub.pars$Bias)
sub.pars$Drift <- as.numeric(sub.pars$Drift)

#### Why remove extreme param values?
sub.pars <- sub.pars %>% 
  group_by(Condition) %>%
  filter(Separation < mean(Separation) + 3 * sd(Separation), 
         Separation > mean(Separation) - 3 * sd(Separation)) %>%
  filter(Non.Decision < mean(Non.Decision) + 3 * sd(Non.Decision), 
         Non.Decision > mean(Non.Decision) - 3 * sd(Non.Decision)) %>%
  filter(Bias < mean(Bias) + 3 * sd(Bias), 
         Bias > mean(Bias) - 3 * sd(Bias)) %>%
  filter(Drift < mean(Drift) + 3 * sd(Drift), 
         Drift > mean(Drift) - 3 * sd(Drift)) %>%
  ungroup() %>%
  na.omit()

sub.pars %<>% gather(Param, Value, Separation:Drift)
```

Summarize and plot param values.

```{r}
sub.pars.ms.adults <- sub.pars %>% 
  group_by(Condition, Param) %>% 
  multi_boot_standard(column = "Value", empirical_function = "mean")

ggplot(aes(x = Param, y = mean, fill = Condition), 
       data = filter(sub.pars.ms.adults, Param %in% c("Drift", "Separation"))) +
  geom_bar(stat = "identity", position = position_dodge()) + 
  geom_linerange(aes(ymin = ci_lower, ymax = ci_upper), 
                 position = position_dodge(width=0.9)) +
  scale_fill_manual(values = c("#4daf4a", "#ff7f00")) +
  theme(text = element_text(size = 30)) +
  xlab("Parameter") +
  ylab("Mean Param Value")
```

## Proportion correct: quintiles

This timecourse analysis follows the anlaysis of Heimler et al., 2015 and Dombrowe et al., 2012. 

First we compute the proportion correct for each quintile bin

```{r}
library("directlabels")

ms_time_slice <- df %>% 
  filter(age_code == "child", is.na(RT_sec) == F, RT <= 2000) %>% 
  mutate(RT_binned = cut(RT_sec, breaks = 4),
         RT_binned_q = lsr::quantileCut(RT_sec, 4)) %>%
  group_by(RT_binned_q, stimuli, Sub.Num) %>% 
  summarise(ss_acc = mean(correct, na.rm=T)) %>% 
  group_by(RT_binned_q, stimuli) %>% 
  multi_boot_standard("ss_acc") 

ms_time_slice$RT_binned_q <- plyr::revalue(ms_time_slice$RT_binned_q, 
                                           c("(0.031,0.3]"= "Q1", 
                                             "(0.3,0.667]" = "Q2",
                                             "(0.667,1]" = "Q3", 
                                             "(1,2]" = "Q4"))

ggplot(aes(x=RT_binned_q, y=mean, color = stimuli, group = stimuli), 
       data = ms_time_slice) + 
  geom_pointrange(aes(ymin = ci_lower, ymax = ci_upper), 
                  position = position_jitter(width = .1)) +
  geom_line() +
  scale_color_solarized() +
  geom_hline(yintercept = 0.5, lty = "dashed") +
  guides(color = F) +
  directlabels::geom_dl(aes(label = stimuli), method = list("last.qp", hjust = -0.3)) +
  xlab("RT Quantile") +
  ylab("Proportion Correct")  +
  theme(text = element_text(size=20)) 
```


## MPT modeling

First attempt at multinomial processing tree model of proportion accuracy over time. 

Here we model the increase in goal-driven behavior over time in the 

```{r}
library(mpt)

# structure the data
mpt_data <- df %>% 
  filter(age_code == "child", is.na(RT_sec) == F) %>% 
  mutate(RT_binned = cut(RT_sec, breaks = 4),
         RT_binned_q = lsr::quantileCut(RT_sec, 4)) %>% 
  select(stimuli, correct, RT_binned_q) %>% 
  group_by(stimuli, correct) %>% 
  summarise(freq = n()) %>% 
  rename(resp = correct) %>% 
  mutate(treeid = 1, resp = as.factor(resp)) %>%
  ungroup()

# formatting to match retroact
mpt_data <- mutate(mpt_data, treeid = ifelse(stimuli == "ASL", 1, ifelse(stimuli == "Face", 2, ifelse(stimuli == "Object", 3, 4))))
mpt_data <- mutate(mpt_data, stimuli = treeid-1)
mpt_data <- mutate(mpt_data, treeid = as.integer(treeid), stimuli = as.integer(stimuli), freq = as.numeric(freq))
mpt_data <- subset(mpt_data, select=c(stimuli, treeid, resp, freq))
  

# write down model
spec <- mptspec(
  ((1 - (1-exp(-rate*(time-curve_onset)))) * 0.5),
  (1-exp(-rate*(time-curve_onset))) + ((1 - (1-exp(-rate*(time-curve_onset)))) * 0.5)
)

spec_2 <- mptspec(
  c*r
)

## TODO: make this model run!

# fit model
mpt1 <- mpt(spec, mpt_data[mpt_data$stimuli == 0, ])

# interpret model coefs
```